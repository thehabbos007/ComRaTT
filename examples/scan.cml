// scan : stable B â‡’ â–¡ (B â†’ A â†’ B) â†’ B â†’ Sig A â†’ Sig B
// scan f acc (a :: as) = accâ€² :: delay (scan f accâ€² (adv as))
// where accâ€² = unbox f acc a
// we only have ints though, so A = B here..
// destructure is .0 and .1 tuple syntax use.
scan : â–¡ (int -> int -> int) -> int -> Sig int -> Sig int
def scan f acc siga =
    // no way to destructure siga?
    let (a, as) = siga in
    let acc_prim = (unbox f) a acc in
    acc_prim :: delay (scan f acc_prim (adv as))

// sum : Sig Nat â†’ Sig Nat
// sum = scan (box (ðœ†m n â†’ m + n)) 0
sum : Sig int -> Sig int
def sum = scan (box (fun m n -> m+n)) 0
